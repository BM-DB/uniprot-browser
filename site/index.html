<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Computational Structure Database</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root{
      --gap:12px;
      --card-border:#ddd;
      --bg:#f8f9fb;
      --card-bg:#fff;
      --sitebar-h:70px;
      --accent:#2563eb;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#222;}

    /* Global site header (match entry.html) */
    .sitebar{
      display:flex;align-items:center;justify-content:space-between;
      padding:16px 24px;border-bottom:1px solid var(--card-border);
      background:#fff;height:var(--sitebar-h);box-sizing:border-box;
    }

    /* Title + logo */
    .site-title{
      display:flex;align-items:center;gap:10px;
      font-size:22px;font-weight:600;margin:0;line-height:1.2;
    }
    .site-title-text{white-space:nowrap;}
    .site-logo{
      height:2em;          /* match text height */
      width:auto;          /* keep aspect ratio */
      display:inline-block;
      vertical-align:middle;
    }

    .main{padding:24px;box-sizing:border-box;height:calc(100vh - var(--sitebar-h));overflow-y:auto;display:flex;flex-direction:column;gap:16px;}

    #search{
      width:100%;max-width:520px;padding:10px 12px;border:1px solid var(--card-border);
      border-radius:8px;font-size:15px;background:#fff;
      box-shadow:0 1px 2px rgba(0,0,0,.04);
    }

    #results{display:flex;flex-direction:column;gap:12px;}

    .entry{
      border:1px solid var(--card-border);border-radius:8px;background:var(--card-bg);
      padding:14px 18px;display:flex;justify-content:space-between;align-items:center;
      transition:background .2s;
    }
    .entry:hover{background:#f5f8ff;}

    .entry-info{display:flex;flex-direction:column;gap:4px;min-width:0;}

    .entry-title{
      font-weight:600;font-size:15px;color:#111;word-break:break-word;
      display:flex;align-items:baseline;gap:8px;flex-wrap:wrap;
    }
    .entry-subtitle{font-weight:400;color:#555;font-size:13px;}

    .entry-desc{color:#555;font-size:13px;word-break:break-word;}

    .btn{
      padding:7px 12px;border:1px solid var(--card-border);border-radius:6px;cursor:pointer;
      background:#fff;font-size:14px;transition:background .2s,border-color .2s;white-space:nowrap;
    }
    .btn:hover{background:#eef4ff;border-color:#8bbcff;}

    .empty,.error{font-size:14px;padding:16px;border-radius:8px;background:#fff;max-width:520px;}
    .empty{color:#666;border:1px dashed #ccc;}
    .error{color:#b00020;border:1px solid #f1c0c4;background:#fff7f7;}

    /* Pagination */
    .pagination{
      display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px;
    }
    .pager{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:36px;height:36px;padding:0 10px;border:1px solid var(--card-border);
      border-radius:8px;background:#fff;cursor:pointer;font-size:14px;
      transition:background .2s,border-color .2s;
    }
    .pager:hover{background:#eef4ff;border-color:#8bbcff;}
    .pager[disabled]{opacity:.5;cursor:not-allowed;background:#f5f5f5;}
    .pager.is-active{
      border-color:var(--accent);background:#eef2ff;font-weight:600;
    }
    .page-meta{font-size:13px;color:#555;margin-left:auto;}
    .pager-ellipsis{padding:0 6px;color:#777;user-select:none;}
  </style>
</head>
<body>
  <!-- Global header -->
  <div class="sitebar">
    <h1 class="site-title">
      <span class="site-title-text">Computational Structure Database</span>
      <img class="site-logo" src="https://raw.githubusercontent.com/BM-DB/uniprot-browser/refs/heads/main/site/graphic1.png" alt="Project logo" />
    </h1>
  </div>

  <div class="main">
    <input id="search" placeholder="Search by UniProt ID or protein name…" aria-label="Search entries" />
    <div id="results"></div>
    <nav id="pagination" class="pagination" aria-label="Results pagination"></nav>
  </div>

  <script>
    // ---- CONFIG: protein names CSV (UniProt ID, Protein Name) ----
    // Keep this pointing at your uniprot-data repo's raw CSV:
    const PROTEIN_NAMES_URL =
      "https://raw.githubusercontent.com/BM-DB/uniprot-data/refs/heads/main/Protein-Metadata/protein_names.csv";

    // Pagination config
    const PAGE_SIZE = 10;

    // ---- Small CSV parser that handles quoted commas & quotes ----
    function parseCSV(text) {
      const rows = [];
      let i = 0, field = '', row = [], inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; continue; } // escaped quote
            inQuotes = false; i++; continue; // end quote
          } else {
            field += c; i++; continue;
          }
        } else {
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ',') { row.push(field); field = ''; i++; continue; }
          if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; i++; continue; }
          if (c === '\r') { i++; continue; } // ignore CR
          field += c; i++;
        }
      }
      // last field
      row.push(field);
      if (row.length > 1 || row[0] !== '') rows.push(row);
      return rows;
    }

    async function fetchProteinNameMap() {
      try {
        const res = await fetch(PROTEIN_NAMES_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const text = await res.text();
        const rows = parseCSV(text);

        // Find header indices
        const header = rows[0]?.map(h => h.trim().toLowerCase()) || [];
        const idIdx = header.indexOf("uniprot id");
        const nameIdx = header.indexOf("protein name");
        if (idIdx === -1 || nameIdx === -1) {
          console.warn("protein_names.csv missing expected headers.");
          return new Map();
        }

        const map = new Map();
        for (let r = 1; r < rows.length; r++) {
          const id = (rows[r][idIdx] || "").trim();
          const name = (rows[r][nameIdx] || "").trim();
          if (id) map.set(id.toUpperCase(), name);
        }
        return map;
      } catch (e) {
        console.error("Failed to load protein_names.csv:", e);
        return new Map();
      }
    }

    async function loadCatalog() {
      const results = document.getElementById('results');
      try {
        // entries.json is one folder up in /data/
        const res = await fetch('../data/entries.json?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        const entries = Array.isArray(json) ? json : (json.entries || []);
        if (!Array.isArray(entries)) throw new Error('entries.json is not an array');
        return entries;
      } catch (e) {
        console.error('Failed to load catalog:', e);
        results.innerHTML = '<div class="error">Error loading catalog (entries.json). Check the file path and server logs.</div>';
        return [];
      }
    }

    // Render the list for a specific page (1-based)
    function renderList(entries, page) {
      const results = document.getElementById('results');
      results.innerHTML = '';

      if (!entries.length) {
        results.innerHTML = '<div class="empty">No matching entries found.</div>';
        return;
      }

      const total = entries.length;
      const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
      const clampedPage = Math.min(Math.max(1, page), totalPages);
      const start = (clampedPage - 1) * PAGE_SIZE;
      const end = Math.min(start + PAGE_SIZE, total);
      const pageItems = entries.slice(start, end);

      pageItems.forEach(entry => {
        const div = document.createElement('div');
        div.className = 'entry';

        const info = document.createElement('div');
        info.className = 'entry-info';

        const title = document.createElement('div');
        title.className = 'entry-title';

        const idSpan = document.createElement('span');
        idSpan.textContent = entry.uniprot_id || '(no ID)';
        title.appendChild(idSpan);

        const nameSpan = document.createElement('span');
        nameSpan.className = 'entry-subtitle';
        if (entry.protein_name) {
          nameSpan.textContent = `— ${entry.protein_name}`;
        } else {
          nameSpan.textContent = '';
        }
        title.appendChild(nameSpan);

        const desc = document.createElement('div');
        desc.className = 'entry-desc';
        const descr = entry.description || (entry.organism ? `Organism: ${entry.organism}` : '');
        if (descr) desc.textContent = descr;

        info.appendChild(title);
        if (descr) info.appendChild(desc);

        const openBtn = document.createElement('button');
        openBtn.className = 'btn';
        openBtn.textContent = 'Open';
        openBtn.onclick = () => {
          window.location.href = `entry.html?uid=${encodeURIComponent(entry.uniprot_id)}`;
        };

        div.appendChild(info);
        div.appendChild(openBtn);
        results.appendChild(div);
      });

      renderPagination(total, clampedPage, totalPages);
    }

    // Build pagination controls
    function renderPagination(totalItems, page, totalPages) {
      const nav = document.getElementById('pagination');
      nav.innerHTML = '';

      if (totalItems === 0) return;

      const makeBtn = (label, onClick, {disabled=false, active=false, ariaLabel=null}={}) => {
        const b = document.createElement('button');
        b.className = 'pager' + (active ? ' is-active' : '');
        b.type = 'button';
        b.textContent = label;
        if (ariaLabel) b.setAttribute('aria-label', ariaLabel);
        if (disabled) b.setAttribute('disabled', 'true');
        if (!disabled && onClick) b.addEventListener('click', onClick);
        return b;
      };

      // Prev
      nav.appendChild(
        makeBtn('‹ Prev', () => goToPage(page - 1), {
          disabled: page <= 1,
          ariaLabel: 'Go to previous page'
        })
      );

      // Page number window (smart: show first, last, current ±2)
      const pagesToShow = new Set([1, totalPages]);
      for (let p = page - 2; p <= page + 2; p++) {
        if (p >= 1 && p <= totalPages) pagesToShow.add(p);
      }
      const ordered = Array.from(pagesToShow).sort((a,b)=>a-b);

      ordered.forEach((p, idx) => {
        if (idx > 0 && p !== ordered[idx - 1] + 1) {
          const ell = document.createElement('span');
          ell.className = 'pager-ellipsis';
          ell.setAttribute('aria-hidden', 'true');
          ell.textContent = '…';
          nav.appendChild(ell);
        }
        nav.appendChild(
          makeBtn(String(p), () => goToPage(p), {
            active: p === page,
            ariaLabel: `Go to page ${p}`
          })
        );
      });

      // Next
      nav.appendChild(
        makeBtn('Next ›', () => goToPage(page + 1), {
          disabled: page >= totalPages,
          ariaLabel: 'Go to next page'
        })
      );

      // Meta text
      const meta = document.createElement('div');
      meta.className = 'page-meta';
      const start = (page - 1) * PAGE_SIZE + 1;
      const end = Math.min(page * PAGE_SIZE, totalItems);
      meta.textContent = `Showing ${start}–${end} of ${totalItems}`;
      nav.appendChild(meta);
    }

    // Global state (within this page)
    let allEntriesWithNames = [];
    let currentFiltered = [];
    let currentPage = 1;

    function goToPage(p) {
      const totalPages = Math.max(1, Math.ceil(currentFiltered.length / PAGE_SIZE));
      currentPage = Math.min(Math.max(1, p), totalPages);
      renderList(currentFiltered, currentPage);
      // Move focus to results wrapper for better SR/keyboard experience
      const res = document.getElementById('results');
      res.setAttribute('tabindex', '-1');
      res.focus({preventScroll:true});
    }

    function applyFilterAndRender() {
      const searchInput = document.getElementById('search');
      const q = searchInput.value.trim().toLowerCase();
      currentFiltered = !q
        ? allEntriesWithNames
        : allEntriesWithNames.filter(e => {
            const id = (e.uniprot_id || '').toLowerCase();
            const nm = (e.protein_name || '').toLowerCase();
            return id.includes(q) || nm.includes(q);
          });
      currentPage = 1; // reset to first page on new filter
      renderList(currentFiltered, currentPage);
    }

    async function main() {
      // Load both datasets
      const [entries, nameMap] = await Promise.all([loadCatalog(), fetchProteinNameMap()]);

      // Merge names into entries array once
      allEntriesWithNames = entries.map(e => ({
        ...e,
        protein_name: nameMap.get((e.uniprot_id || '').toUpperCase()) || ''
      }));

      // Hook up search
      const searchInput = document.getElementById('search');
      searchInput.addEventListener('input', applyFilterAndRender);

      // Initial render
      currentFiltered = allEntriesWithNames;
      renderList(currentFiltered, currentPage);
    }

    main();
  </script>
</body>
</html>
