<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Computational Structure Database</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root{
      --gap:12px;
      --card-border:#ddd;
      --bg:#f8f9fb;
      --card-bg:#fff;
      --sitebar-h:70px;
      --accent:#2563eb;
      --shadow: 0 4px 16px rgba(0,0,0,.08);
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#222;}

    /* Global site header (match entry.html) */
    .sitebar{
      display:flex;align-items:center;justify-content:space-between;
      padding:16px 24px;border-bottom:1px solid var(--card-border);
      background:#fff;height:var(--sitebar-h);box-sizing:border-box;
    }
    .site-title{font-size:22px;font-weight:600;margin:0;}

    .main{
      padding:24px;box-sizing:border-box;height:calc(100vh - var(--sitebar-h));
      overflow-y:auto;display:flex;flex-direction:column;gap:16px;
    }

    /* --- Searchbar with icon button --- */
    .searchbar{
      position:relative;width:100%;max-width:520px;
    }
    #search{
      width:100%;padding:10px 44px 10px 12px;border:1px solid var(--card-border);
      border-radius:8px;font-size:15px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.04);
    }
    #search:focus{outline:none;border-color:#b9cdfc;box-shadow:0 0 0 3px rgba(37,99,235,.12);}
    #searchBtn{
      position:absolute;right:6px;top:50%;transform:translateY(-50%);
      width:32px;height:32px;border:1px solid var(--card-border);border-radius:8px;
      background:#fff;display:flex;align-items:center;justify-content:center;
      cursor:pointer;transition:background .2s,border-color .2s;
    }
    #searchBtn:hover{background:#eef4ff;border-color:#8bbcff;}
    #searchBtn svg{width:18px;height:18px;display:block;}

    /* Typeahead popup */
    .suggestions{
      position:absolute;top:100%;left:0;width:100%;margin-top:6px;z-index:10;
      background:#fff;border:1px solid var(--card-border);border-radius:10px;
      box-shadow:var(--shadow);overflow:hidden;display:none;
    }
    .suggestions.show{display:block;}
    .sugg-item{
      display:flex;gap:8px;align-items:flex-start;padding:10px 12px;cursor:pointer;
      transition:background .12s;font-size:14px;
    }
    .sugg-item:hover,.sugg-item.active{background:#f4f7ff;}
    .sugg-id{font-weight:600;color:#111;}
    .sugg-name{color:#555;}
    .sugg-desc{color:#666;font-size:12px;margin-top:2px;}
    .sugg-empty{padding:10px 12px;color:#777;font-size:13px;}

    #results{display:flex;flex-direction:column;gap:12px;}

    .entry{
      border:1px solid var(--card-border);border-radius:8px;background:var(--card-bg);
      padding:14px 18px;display:flex;justify-content:space-between;align-items:center;
      transition:background .2s;
    }
    .entry:hover{background:#f5f8ff;}

    .entry-info{display:flex;flex-direction:column;gap:4px;min-width:0;}

    .entry-title{
      font-weight:600;font-size:15px;color:#111;word-break:break-word;
      display:flex;align-items:baseline;gap:8px;flex-wrap:wrap;
    }
    .entry-subtitle{font-weight:400;color:#555;font-size:13px;}

    .entry-desc{color:#555;font-size:13px;word-break:break-word;}

    .btn{
      padding:7px 12px;border:1px solid var(--card-border);border-radius:6px;cursor:pointer;
      background:#fff;font-size:14px;transition:background .2s,border-color .2s;white-space:nowrap;
    }
    .btn:hover{background:#eef4ff;border-color:#8bbcff;}

    .empty,.error{font-size:14px;padding:16px;border-radius:8px;background:#fff;max-width:520px;}
    .empty{color:#666;border:1px dashed #ccc;}
    .error{color:#b00020;border:1px solid #f1c0c4;background:#fff7f7;}

    /* Pagination */
    .pagination{
      display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px;
    }
    .pager{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:36px;height:36px;padding:0 10px;border:1px solid var(--card-border);
      border-radius:8px;background:#fff;cursor:pointer;font-size:14px;
      transition:background .2s,border-color .2s;
    }
    .pager:hover{background:#eef4ff;border-color:#8bbcff;}
    .pager[disabled]{opacity:.5;cursor:not-allowed;background:#f5f5f5;}
    .pager.is-active{
      border-color:var(--accent);background:#eef2ff;font-weight:600;
    }
    .page-meta{font-size:13px;color:#555;margin-left:auto;}
    .pager-ellipsis{padding:0 6px;color:#777;user-select:none;}
  </style>
</head>
<body>
  <!-- Global header -->
  <div class="sitebar">
    <h1 class="site-title">Computational Structure Database</h1>
  </div>

  <div class="main">
    <!-- Search with icon & popup -->
    <div class="searchbar" role="combobox" aria-haspopup="listbox" aria-owns="suggestions" aria-expanded="false">
      <input id="search" placeholder="Search by UniProt ID or protein name…" aria-label="Search entries" autocomplete="off" />
      <button id="searchBtn" aria-label="Search">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
             stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="11" cy="11" r="7"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </button>
      <div id="suggestions" class="suggestions" role="listbox" aria-label="Search suggestions"></div>
    </div>

    <div id="results"></div>
    <nav id="pagination" class="pagination" aria-label="Results pagination"></nav>
  </div>

  <script>
    // ---- CONFIG: protein names CSV (UniProt ID, Protein Name) ----
    const PROTEIN_NAMES_URL =
      "https://raw.githubusercontent.com/BM-DB/uniprot-data/refs/heads/main/Protein-Metadata/protein_names.csv";

    // Pagination config
    const PAGE_SIZE = 10;

    // ---- Small CSV parser that handles quoted commas & quotes ----
    function parseCSV(text) {
      const rows = [];
      let i = 0, field = '', row = [], inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') { field += '"'; i += 2; continue; } // escaped quote
            inQuotes = false; i++; continue; // end quote
          } else {
            field += c; i++; continue;
          }
        } else {
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ',') { row.push(field); field = ''; i++; continue; }
          if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; i++; continue; }
          if (c === '\r') { i++; continue; } // ignore CR
          field += c; i++;
        }
      }
      row.push(field);
      if (row.length > 1 || row[0] !== '') rows.push(row);
      return rows;
    }

    async function fetchProteinNameMap() {
      try {
        const res = await fetch(PROTEIN_NAMES_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const text = await res.text();
        const rows = parseCSV(text);

        const header = rows[0]?.map(h => h.trim().toLowerCase()) || [];
        const idIdx = header.indexOf("uniprot id");
        const nameIdx = header.indexOf("protein name");
        if (idIdx === -1 || nameIdx === -1) {
          console.warn("protein_names.csv missing expected headers.");
          return new Map();
        }

        const map = new Map();
        for (let r = 1; r < rows.length; r++) {
          const id = (rows[r][idIdx] || "").trim();
          const name = (rows[r][nameIdx] || "").trim();
          if (id) map.set(id.toUpperCase(), name);
        }
        return map;
      } catch (e) {
        console.error("Failed to load protein_names.csv:", e);
        return new Map();
      }
    }

    async function loadCatalog() {
      const results = document.getElementById('results');
      try {
        // entries.json is one folder up in /data/
        const res = await fetch('../data/entries.json?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        const entries = Array.isArray(json) ? json : (json.entries || []);
        if (!Array.isArray(entries)) throw new Error('entries.json is not an array');
        return entries;
      } catch (e) {
        console.error('Failed to load catalog:', e);
        results.innerHTML = '<div class="error">Error loading catalog (entries.json). Check the file path and server logs.</div>';
        return [];
      }
    }

    // Render the list for a specific page (1-based)
    function renderList(entries, page) {
      const results = document.getElementById('results');
      results.innerHTML = '';

      if (!entries.length) {
        results.innerHTML = '<div class="empty">No matching entries found.</div>';
        document.getElementById('pagination').innerHTML = '';
        return;
      }

      const total = entries.length;
      const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
      const clampedPage = Math.min(Math.max(1, page), totalPages);
      const start = (clampedPage - 1) * PAGE_SIZE;
      const end = Math.min(start + PAGE_SIZE, total);
      const pageItems = entries.slice(start, end);

      pageItems.forEach(entry => {
        const div = document.createElement('div');
        div.className = 'entry';

        const info = document.createElement('div');
        info.className = 'entry-info';

        const title = document.createElement('div');
        title.className = 'entry-title';

        const idSpan = document.createElement('span');
        idSpan.textContent = entry.uniprot_id || '(no ID)';
        title.appendChild(idSpan);

        const nameSpan = document.createElement('span');
        nameSpan.className = 'entry-subtitle';
        nameSpan.textContent = entry.protein_name ? `— ${entry.protein_name}` : '';
        title.appendChild(nameSpan);

        const desc = document.createElement('div');
        desc.className = 'entry-desc';
        const descr = entry.description || (entry.organism ? `Organism: ${entry.organism}` : '');
        if (descr) desc.textContent = descr;

        info.appendChild(title);
        if (descr) info.appendChild(desc);

        const openBtn = document.createElement('button');
        openBtn.className = 'btn';
        openBtn.textContent = 'Open';
        openBtn.onclick = () => {
          window.location.href = `entry.html?uid=${encodeURIComponent(entry.uniprot_id)}`;
        };

        div.appendChild(info);
        div.appendChild(openBtn);
        results.appendChild(div);
      });

      renderPagination(total, clampedPage, totalPages);
    }

    // Build pagination controls
    function renderPagination(totalItems, page, totalPages) {
      const nav = document.getElementById('pagination');
      nav.innerHTML = '';

      if (totalItems === 0) return;

      const makeBtn = (label, onClick, {disabled=false, active=false, ariaLabel=null}={}) => {
        const b = document.createElement('button');
        b.className = 'pager' + (active ? ' is-active' : '');
        b.type = 'button';
        b.textContent = label;
        if (ariaLabel) b.setAttribute('aria-label', ariaLabel);
        if (disabled) b.setAttribute('disabled', 'true');
        if (!disabled && onClick) b.addEventListener('click', onClick);
        return b;
      };

      // Prev
      nav.appendChild(
        makeBtn('‹ Prev', () => goToPage(page - 1), {
          disabled: page <= 1,
          ariaLabel: 'Go to previous page'
        })
      );

      // Page number window (first, last, current ±2)
      const pagesToShow = new Set([1, totalPages]);
      for (let p = page - 2; p <= page + 2; p++) {
        if (p >= 1 && p <= totalPages) pagesToShow.add(p);
      }
      const ordered = Array.from(pagesToShow).sort((a,b)=>a-b);

      ordered.forEach((p, idx) => {
        if (idx > 0 && p !== ordered[idx - 1] + 1) {
          const ell = document.createElement('span');
          ell.className = 'pager-ellipsis';
          ell.setAttribute('aria-hidden', 'true');
          ell.textContent = '…';
          nav.appendChild(ell);
        }
        nav.appendChild(
          makeBtn(String(p), () => goToPage(p), {
            active: p === page,
            ariaLabel: `Go to page ${p}`
          })
        );
      });

      // Next
      nav.appendChild(
        makeBtn('Next ›', () => goToPage(page + 1), {
          disabled: page >= totalPages,
          ariaLabel: 'Go to next page'
        })
      );

      // Meta text
      const meta = document.createElement('div');
      meta.className = 'page-meta';
      const start = (page - 1) * PAGE_SIZE + 1;
      const end = Math.min(page * PAGE_SIZE, totalItems);
      meta.textContent = `Showing ${start}–${end} of ${totalItems}`;
      nav.appendChild(meta);
    }

    // Global state
    let allEntriesWithNames = [];
    let currentFiltered = [];
    let currentPage = 1;

    // Suggestions (typeahead) state
    let activeIndex = -1; // keyboard highlight
    const MAX_SUGG = 8;

    function goToPage(p) {
      const totalPages = Math.max(1, Math.ceil(currentFiltered.length / PAGE_SIZE));
      currentPage = Math.min(Math.max(1, p), totalPages);
      renderList(currentFiltered, currentPage);
      const results = document.getElementById('results');
      results.setAttribute('tabindex', '-1');
      results.focus({preventScroll:true});
    }

    function filterEntries(q) {
      if (!q) return allEntriesWithNames;
      const needle = q.trim().toLowerCase();
      return allEntriesWithNames.filter(e => {
        const id = (e.uniprot_id || '').toLowerCase();
        const nm = (e.protein_name || '').toLowerCase();
        return id.includes(needle) || nm.includes(needle);
      });
    }

    function applyFilterAndRender() {
      const searchInput = document.getElementById('search');
      currentFiltered = filterEntries(searchInput.value);
      currentPage = 1;
      renderList(currentFiltered, currentPage);
      renderSuggestions(searchInput.value); // keep suggestions in sync
    }

    // --- Suggestions rendering ---
    function renderSuggestions(q) {
      const sugg = document.getElementById('suggestions');
      const wrapper = document.querySelector('.searchbar');
      const expanded = !!q && q.trim().length > 0;

      sugg.innerHTML = '';
      activeIndex = -1;

      if (!expanded) {
        sugg.classList.remove('show');
        wrapper.setAttribute('aria-expanded', 'false');
        return;
      }

      const matches = filterEntries(q).slice(0, MAX_SUGG);
      if (matches.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'sugg-empty';
        empty.textContent = 'No matches';
        sugg.appendChild(empty);
        sugg.classList.add('show');
        wrapper.setAttribute('aria-expanded', 'true');
        return;
      }

      matches.forEach((e, idx) => {
        const item = document.createElement('div');
        item.className = 'sugg-item';
        item.setAttribute('role', 'option');
        item.setAttribute('id', 'sugg-' + idx);

        const textWrap = document.createElement('div');
        const line1 = document.createElement('div');
        const idEl = document.createElement('span');
        idEl.className = 'sugg-id';
        idEl.textContent = e.uniprot_id || '(no ID)';
        const nameEl = document.createElement('span');
        nameEl.className = 'sugg-name';
        nameEl.textContent = e.protein_name ? ` — ${e.protein_name}` : '';
        line1.appendChild(idEl);
        line1.appendChild(nameEl);

        const line2 = document.createElement('div');
        line2.className = 'sugg-desc';
        const descr = e.description || (e.organism ? `Organism: ${e.organism}` : '');
        if (descr) line2.textContent = descr;

        textWrap.appendChild(line1);
        if (descr) textWrap.appendChild(line2);

        item.appendChild(textWrap);

        item.addEventListener('mousedown', (evt) => {
          // mousedown so click doesn’t blur input before we handle it
          evt.preventDefault();
          openEntry(e.uniprot_id);
        });

        sugg.appendChild(item);
      });

      sugg.classList.add('show');
      wrapper.setAttribute('aria-expanded', 'true');
    }

    function moveActive(delta) {
      const sugg = document.getElementById('suggestions');
      const items = Array.from(sugg.querySelectorAll('.sugg-item'));
      if (items.length === 0) return;

      activeIndex = (activeIndex + delta + items.length) % items.length;
      items.forEach((el, i) => el.classList.toggle('active', i === activeIndex));
      const activeEl = items[activeIndex];
      if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
    }

    function activateCurrentSuggestion() {
      const sugg = document.getElementById('suggestions');
      const items = Array.from(sugg.querySelectorAll('.sugg-item'));
      if (activeIndex >= 0 && activeIndex < items.length) {
        const idText = items[activeIndex].querySelector('.sugg-id')?.textContent || '';
        if (idText) openEntry(idText);
        hideSuggestions();
      } else {
        // No active item: trigger normal search
        applyFilterAndRender();
      }
    }

    function hideSuggestions() {
      const sugg = document.getElementById('suggestions');
      const wrapper = document.querySelector('.searchbar');
      sugg.classList.remove('show');
      wrapper.setAttribute('aria-expanded', 'false');
      activeIndex = -1;
    }

    function openEntry(uid) {
      if (!uid) return;
      window.location.href = `entry.html?uid=${encodeURIComponent(uid)}`;
    }

    async function main() {
      const [entries, nameMap] = await Promise.all([loadCatalog(), fetchProteinNameMap()]);

      allEntriesWithNames = entries.map(e => ({
        ...e,
        protein_name: nameMap.get((e.uniprot_id || '').toUpperCase()) || ''
      }));

      // Initial list
      currentFiltered = allEntriesWithNames;
      renderList(currentFiltered, currentPage);

      // Wire up search behaviors
      const input = document.getElementById('search');
      const btn = document.getElementById('searchBtn');
      const sugg = document.getElementById('suggestions');

      input.addEventListener('input', () => {
        renderSuggestions(input.value);
        // Do not filter the main list on every keystroke if you prefer—currently we do:
        applyFilterAndRender();
      });

      input.addEventListener('focus', () => {
        if (input.value.trim()) renderSuggestions(input.value);
      });

      input.addEventListener('keydown', (e) => {
        if (!sugg.classList.contains('show')) return;
        if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(1); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); moveActive(-1); }
        else if (e.key === 'Enter') { e.preventDefault(); activateCurrentSuggestion(); }
        else if (e.key === 'Escape') { hideSuggestions(); }
      });

      btn.addEventListener('click', () => {
        hideSuggestions();
        applyFilterAndRender();
        document.getElementById('results').scrollIntoView({behavior:'smooth', block:'start'});
      });

      // Close suggestions when clicking outside
      document.addEventListener('click', (e) => {
        const bar = document.querySelector('.searchbar');
        if (!bar.contains(e.target)) hideSuggestions();
      });
    }

    main();
  </script>
</body>
</html>
