<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Computational Structure Database</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root {
      --gap: 12px;
      --card-border: #ddd;
      --bg: #f8f9fb;
      --card-bg: #fff;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #222;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid var(--card-border);
      background: #fff;
      height: 70px; /* match entry.html’s --sitebar-h */
      box-sizing: border-box;
    }


    .title {
      font-size: 22px;
      font-weight: 600;
      margin: 0;
    }

    .main {
      padding: 24px;
      box-sizing: border-box;
      height: calc(100vh - 70px);
      overflow-y: auto;
    }

    #search {
      width: 100%;
      max-width: 420px;
      padding: 10px 12px;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      font-size: 15px;
      margin-bottom: 24px;
      background: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }

    #results {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .entry {
      border: 1px solid var(--card-border);
      border-radius: 8px;
      background: var(--card-bg);
      padding: 14px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }
    .entry:hover {
      background: #f5f8ff;
    }

    .entry-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .entry-title {
      font-weight: 600;
      font-size: 15px;
      color: #111;
      word-break: break-word;
      display: flex;
      align-items: baseline;
      gap: 8px;
      flex-wrap: wrap;
    }
    .entry-subtitle {
      font-weight: 400;
      color: #555;
      font-size: 13px;
    }

    .entry-desc {
      color: #555;
      font-size: 13px;
      word-break: break-word;
    }

    .btn {
      padding: 7px 12px;
      border: 1px solid var(--card-border);
      border-radius: 6px;
      cursor: pointer;
      background: #fff;
      font-size: 14px;
      transition: background 0.2s, border-color 0.2s;
      white-space: nowrap;
    }
    .btn:hover {
      background: #eef4ff;
      border-color: #8bbcff;
    }

    .empty, .error {
      font-size: 14px;
      padding: 16px;
      border-radius: 8px;
      background: #fff;
      max-width: 520px;
    }
    .empty {
      color: #666;
      border: 1px dashed #ccc;
    }
    .error {
      color: #b00020;
      border: 1px solid #f1c0c4;
      background: #fff7f7;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <h1 class="title">Computational Structure Database</h1>
  </div>

  <div class="main">
    <input id="search" placeholder="Search UniProt ID..." />
    <div id="results"></div>
  </div>

  <script>
    // --- UniProt name cache and fetcher (best available name)
    const uniprotNameCache = new Map(); // uid -> string | null | Promise<string|null>
    const UNIPROT_BASE = 'https://rest.uniprot.org/uniprotkb/';

    async function fetchUniProtBestName(uid) {
      if (!uid) return null;
      if (uniprotNameCache.has(uid)) {
        const v = uniprotNameCache.get(uid);
        return v instanceof Promise ? v : v;
        // if it was a resolved string/null, we return directly; if it's a Promise, await below
      }
      const p = (async () => {
        try {
          const res = await fetch(UNIPROT_BASE + encodeURIComponent(uid) + '.json', { cache: 'no-store' });
          if (!res.ok) return null;
          const data = await res.json();
          const pd = data?.proteinDescription;

          // Preferred: recommendedName fullName
          const rec = pd?.recommendedName?.fullName?.value;
          if (rec) return rec;

          // Fallbacks: alternativeNames, submissionNames, shortName variants
          const altArr = pd?.alternativeNames;
          if (Array.isArray(altArr) && altArr.length) {
            const altFull  = altArr[0]?.fullName?.value;
            if (altFull) return altFull;
            const altShort = altArr[0]?.shortName?.[0]?.value;
            if (altShort) return altShort;
          }
          const subArr = pd?.submissionNames;
          if (Array.isArray(subArr) && subArr.length) {
            const subFull  = subArr[0]?.fullName?.value;
            if (subFull) return subFull;
            const subShort = subArr[0]?.shortName?.[0]?.value;
            if (subShort) return subShort;
          }

          const recShort = pd?.recommendedName?.shortName?.[0]?.value;
          if (recShort) return recShort;

          return null;
        } catch { return null; }
      })();

      // Store the promise first to coalesce concurrent requests
      uniprotNameCache.set(uid, p);
      const resolved = await p;
      // Replace the promise with the final value
      uniprotNameCache.set(uid, resolved);
      return resolved;
    }

    async function loadCatalog() {
      const results = document.getElementById('results');
      try {
        // IMPORTANT: match entry.html — catalog is one folder up in /data/
        const res = await fetch('../data/entries.json?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();

        // Support either { entries: [...] } or [...] at top level
        const entries = Array.isArray(json) ? json : (json.entries || []);
        if (!Array.isArray(entries)) throw new Error('entries.json is not an array');

        return entries;
      } catch (e) {
        console.error('Failed to load catalog:', e);
        results.innerHTML = '<div class="error">Error loading catalog (entries.json). Check the file path and server logs.</div>';
        return [];
      }
    }

    // Render token to avoid race when typing in search
    let renderToken = 0;

    function render(entries) {
      const token = ++renderToken;
      const results = document.getElementById('results');
      results.innerHTML = '';

      if (!entries.length) {
        results.innerHTML = '<div class="empty">No matching entries found.</div>';
        return;
      }

      entries.forEach(entry => {
        const div = document.createElement('div');
        div.className = 'entry';

        const info = document.createElement('div');
        info.className = 'entry-info';

        const title = document.createElement('div');
        title.className = 'entry-title';

        const idSpan = document.createElement('span');
        idSpan.textContent = entry.uniprot_id || '(no ID)';
        title.appendChild(idSpan);

        const nameSpan = document.createElement('span');
        nameSpan.className = 'entry-subtitle';
        // initially blank; will populate asynchronously
        title.appendChild(nameSpan);

        const desc = document.createElement('div');
        desc.className = 'entry-desc';
        const descr = entry.description || (entry.organism ? `Organism: ${entry.organism}` : '');
        if (descr) desc.textContent = descr;

        info.appendChild(title);
        if (descr) info.appendChild(desc);

        const openBtn = document.createElement('button');
        openBtn.className = 'btn';
        openBtn.textContent = 'Open';
        openBtn.onclick = () => {
          window.location.href = `entry.html?uid=${encodeURIComponent(entry.uniprot_id)}`;
        };

        div.appendChild(info);
        div.appendChild(openBtn);
        results.appendChild(div);

        // Fill the best-available UniProt name (non-blocking)
        const uid = entry.uniprot_id;
        if (uid) {
          fetchUniProtBestName(uid).then(name => {
            if (token !== renderToken) return; // stale render guard
            if (name) nameSpan.textContent = `— ${name}`;
          });
        }
      });
    }

    async function main() {
      const entries = await loadCatalog();
      const searchInput = document.getElementById('search');

      function filterAndRender() {
        const q = searchInput.value.trim().toLowerCase();
        const filtered = !q
          ? entries
          : entries.filter(e => (e.uniprot_id || '').toLowerCase().includes(q));
        render(filtered);
      }

      searchInput.addEventListener('input', filterAndRender);
      filterAndRender();
    }

    main();
  </script>
</body>
</html>
