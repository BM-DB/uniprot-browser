<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Entry</title>
  <link rel="stylesheet" href="styles.css" />
  <!-- PDBe Mol* (pinned) -->
  <script src="https://unpkg.com/pdbe-molstar@3.7.1/build/pdbe-molstar-plugin.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/pdbe-molstar@3.7.1/build/pdbe-molstar-light.css" />

  <style>
    :root { --gap: 12px; --card-border: #ddd; --accent: #193F90; }
    html, body { height: 100%; margin: 0; background: #fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    /* Header */
    .topbar { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-bottom: 1px solid var(--card-border); }
    .topbar a { text-decoration: none; }
    .title { font-size: 20px; font-weight: 600; margin: 0; }

    /* 2-column layout */
    .main {
      height: calc(100vh - 54px);
      display: flex;
      gap: var(--gap);
      padding: var(--gap);
      box-sizing: border-box;
    }
    .col {
      flex: 1 1 50%;
      min-width: 0;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
    }

    /* Left: Mol* viewer fills column */
    #viewer-wrap { position: relative; flex: 1 1 auto; }
    #viewer { position: absolute; inset: 0; }
    #viewer .msp-viewport, #viewer canvas {
      width: 100% !important; height: 100% !important;
      max-width: 100% !important; max-height: 100% !important;
    }
    /* Hide Mol* UI chrome */
    .msp-left-panel,.msp-right-panel,.msp-bottom-panel,
    .msp-layout-controls,.msp-viewport-controls,
    .msp-plugin-ui,.msp-controls,.msp-controls-wrapper,.msp-help-toast {
      display: none !important; visibility: hidden !important; pointer-events: none !important;
    }

    /* Right: sequence panel */
    .seq-header {
      display: flex; align-items: center; gap: 12px;
      padding: 10px 12px; border-bottom: 1px solid var(--card-border);
      background: #fafafa; flex-wrap: wrap;
    }
    .seq-header strong { margin-right: 4px; }
    .seq-header a { text-decoration: none; }
    .btn { padding: 6px 10px; border: 1px solid var(--card-border); border-radius: 6px; cursor: pointer; background: #fff; }
    .btn.secondary { background: #f5f5f5; }

    .seq-body { flex: 1 1 auto; overflow: auto; padding: 12px; }
    .seq-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(16px, 1fr));
      gap: 4px;
      align-content: start;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      user-select: none;
    }
    .res {
      display: inline-flex; align-items: center; justify-content: center;
      height: 22px; min-width: 16px; padding: 0 4px; border-radius: 4px;
      cursor: pointer; border: 1px solid transparent;
      transition: background 80ms ease, border-color 80ms ease;
      font-size: 13px; line-height: 1;
    }
    .res:hover { background: #eef3ff; border-color: #c8d8ff; }
    .res.active { background: #dfe8ff; border-color: var(--accent); }
    .res.dim { opacity: 0.35; }
    .legend { margin: 8px 0 0; color: #666; font-size: 12px; }

    .error { color: #b00020; padding: 8px 12px; border-top: 1px solid var(--card-border); background: #fff7f7; display:none; }
    .spacer { flex: 1 1 auto; }
  </style>
</head>
<body>
  <div class="topbar">
    <a href="index.html">← Back</a>
    <h1 id="title" class="title"></h1>
  </div>

  <div class="main">
    <!-- Left: Mol* viewer -->
    <div class="col">
      <div id="viewer-wrap"><div id="viewer"></div></div>
      <div id="viewer-error" class="error"></div>
    </div>

    <!-- Right: sequence + links + interactive residues -->
    <div class="col">
      <div class="seq-header">
        <strong>Files:</strong>
        <a id="cifLink"   target="_blank" rel="noopener">CIF</a>
        <a id="fastaLink" target="_blank" rel="noopener">FASTA</a>
        <button id="copyBtn" class="btn" type="button">Copy FASTA</button>
        <span class="spacer"></span>
        <button id="clearSelBtn" class="btn secondary" type="button">Clear Selection</button>
      </div>
      <div class="seq-body">
        <div id="seqGrid" class="seq-grid" aria-label="Protein sequence (click/shift/ctrl to select)"></div>
        <div class="legend" id="seqLegend"></div>
      </div>
      <div id="seq-error" class="error"></div>
    </div>
  </div>

  <script>
    function getParam(name){ return new URL(location.href).searchParams.get(name); }

    async function load(){
      const uid = getParam('uid');
      const titleEl   = document.getElementById('title');
      const seqGrid   = document.getElementById('seqGrid');
      const seqLegend = document.getElementById('seqLegend');
      const copyBtn   = document.getElementById('copyBtn');
      const clearBtn  = document.getElementById('clearSelBtn');
      const cifLink   = document.getElementById('cifLink');
      const fastaLink = document.getElementById('fastaLink');
      const viewerErr = document.getElementById('viewer-error');
      const seqErr    = document.getElementById('seq-error');

      titleEl.textContent = uid || '(missing uid)';

      // Load catalog
      let catalog;
      try {
        catalog = await fetch('../data/entries.json?v=' + Date.now()).then(r=>r.json());
      } catch {
        viewerErr.style.display = seqErr.style.display = 'block';
        viewerErr.textContent = seqErr.textContent = 'Could not load entries.json.';
        return;
      }
      const entry = (catalog.entries || []).find(e => e.uniprot_id === uid);
      if(!entry){
        viewerErr.style.display = seqErr.style.display = 'block';
        viewerErr.textContent = seqErr.textContent = 'Entry not found in catalog.';
        return;
      }

      const cifUrl   = entry.files.structure_cif;
      const fastaUrl = entry.files.sequence_fasta;
      cifLink.href   = cifUrl;
      fastaLink.href = fastaUrl;

      // ===== Right: build interactive sequence =====
      let FASTA = '';
      try {
        FASTA = await fetch(fastaUrl).then(r=>r.text());
      } catch {
        seqErr.style.display = 'block';
        seqErr.textContent = 'FASTA not available.';
      }

      const lines = FASTA.split(/\r?\n/).filter(Boolean);
      const header = lines[0]?.startsWith('>') ? lines[0] : null;
      const seq = (header ? lines.slice(1) : lines).join('').replace(/\s+/g,'');
      seqLegend.textContent = header ? header : '';

      // Render residues
      seqGrid.innerHTML = '';
      const resEls = [];
      for (let i = 0; i < seq.length; i++) {
        const aa = seq[i];
        const pos = i + 1; // 1-based
        const span = document.createElement('span');
        span.className = 'res';
        span.textContent = aa;
        span.title = `Residue ${pos} (${aa})`;
        span.dataset.pos = String(pos);
        seqGrid.appendChild(span);
        resEls.push(span);
      }

      // Selection state
      const selected = new Set();   // of 1-based positions
      let lastClickedPos = null;

      function renderSelectionDim() {
        if (selected.size === 0) {
          resEls.forEach(el => { el.classList.remove('dim','active'); });
          return;
        }
        resEls.forEach(el => {
          const pos = Number(el.dataset.pos);
          const isSel = selected.has(pos);
          el.classList.toggle('active', isSel);
          el.classList.toggle('dim', !isSel);
        });
      }

      function addPos(pos){ selected.add(pos); }
      function removePos(pos){ selected.delete(pos); }
      function addRange(a,b){
        const [lo,hi] = a <= b ? [a,b] : [b,a];
        for(let p=lo;p<=hi;p++) selected.add(p);
      }
      function clearSelection(){
        selected.clear();
        renderSelectionDim();
        try { pdbe.visual?.clearSelection?.(); } catch {}
      }

      // Hover
      seqGrid.addEventListener('mouseover', e => {
        const t = e.target;
        if (!(t instanceof HTMLElement) || !t.classList.contains('res')) return;
        t.classList.add('active');
      });
      seqGrid.addEventListener('mouseout', e => {
        const t = e.target;
        if (!(t instanceof HTMLElement) || !t.classList.contains('res')) return;
        t.classList.remove('active');
      });

      // Copy FASTA
      copyBtn.onclick = async () => {
        try {
          await navigator.clipboard.writeText(FASTA || seq);
          const prev = copyBtn.textContent;
          copyBtn.textContent = 'Copied!';
          setTimeout(()=> (copyBtn.textContent = prev), 1200);
        } catch {}
      };
      clearBtn.onclick = () => clearSelection();

      // ===== Left: PDBe Mol* viewer (direct) =====
      const fmt = (cifUrl.toLowerCase().endsWith('.cif') && !cifUrl.toLowerCase().endsWith('.mmcif')) ? 'cif' : 'mmcif';
      let pdbe;
      try {
        pdbe = new PDBeMolstarPlugin();
      } catch {
        viewerErr.style.display = 'block';
        viewerErr.textContent = 'Failed to create PDBe Mol* plugin.';
        return;
      }
      try {
        pdbe.render('viewer', {
          customData: { url: cifUrl, format: fmt },
          hideControls: true, expanded: false,
          bgColor: { r:255, g:255, b:255 }
        });
      } catch {
        viewerErr.style.display = 'block';
        viewerErr.textContent = 'Mol* render error.';
        return;
      }

      // Keep viewer chrome hidden
      const root = document.getElementById('viewer');
      const hideChrome = () => {
        [
          '.msp-left-panel','.msp-right-panel','.msp-bottom-panel',
          '.msp-layout-controls','.msp-viewport-controls',
          '.msp-plugin-ui','.msp-controls','.msp-controls-wrapper','.msp-help-toast'
        ].forEach(sel => {
          document.querySelectorAll(sel).forEach(el => {
            el.style.display='none'; el.style.visibility='hidden'; el.style.pointerEvents='none';
          });
        });
      };
      hideChrome(); setTimeout(hideChrome, 100); setTimeout(hideChrome, 500);
      new MutationObserver(hideChrome).observe(root, { childList:true, subtree:true });

      // Mild ambient + outline + uniform color (best-effort)
      function styleScene() {
        try {
          const plugin = pdbe?.viewerInstance?.plugin;
          const c3d = plugin?.canvas3d;
          if (c3d?.setProps) {
            c3d.setProps({
              renderer: { ambientIntensity: 0.6 },
              postprocessing: { outline: { enable: true, scale: 1.0, threshold: 0.8 } }
            });
          }
          const reps = plugin?.managers?.structure?.representation?.componentReprs || [];
          const val = { r: 70/255, g: 130/255, b: 180/255 };
          reps.forEach(cr => { try { cr.setTheme?.({ color: { name: 'uniform', params: { value: val } } }); } catch {} });
        } catch {}
      }
      setTimeout(styleScene, 400);
      setTimeout(styleScene, 1200);

      // ===== Map sequence positions -> correct chain & residue numbers =====
      // We try to discover a suitable polymer chain and confirm that "pos" ~ label_seq_id.
      let chainIdGuess = 'A';
      let seqIdLooks1Based = true;

      function discoverMapping() {
        try {
          const plugin = pdbe?.viewerInstance?.plugin;
          const structures = plugin?.managers?.structure?.hierarchy?.current?.structures || [];
          const first = structures[0];
          const ah = first?.cell?.obj?.data?.model?.atomicHierarchy;
          if (!ah) return;

          // pick the polymer chain with most residues
          const chains = ah?.chains;
          const residues = ah?.residues;
          const chainIdxBeg = chains?.offsets?.index ?? chains?.offsets?.indices;
          const chainIdxEnd = chains?.offsets?.end ?? chains?.offsets?.indicesEnd;
          const label_asym_id = chains?.label_asym_id?.toArray?.();
          const label_seq_id = residues?.label_seq_id?.toArray?.();

          if (label_asym_id && chainIdxBeg && chainIdxEnd) {
            let best = { id: 'A', len: -1 };
            for (let c = 0; c < label_asym_id.length; c++) {
              const beg = chainIdxBeg[c] ?? 0;
              const end = chainIdxEnd[c] ?? beg;
              const len = Math.max(0, end - beg);
              if (len > best.len) best = { id: label_asym_id[c], len };
            }
            if (best.len > 0) chainIdGuess = best.id;
          }

          // Heuristic: if label_seq_id starts at 1 for polymers, assume seq pos == label_seq_id
          if (label_seq_id && label_seq_id.length) {
            const min = Math.min(...label_seq_id.filter(n => Number.isFinite(n)));
            seqIdLooks1Based = (min === 1);
          }
        } catch {
          /* keep defaults */
        }
      }
      // Try mapping after the scene settles
      setTimeout(discoverMapping, 500);
      setTimeout(discoverMapping, 1500);

      // Build PDBe selection data from Set of positions
      function buildSelectionData() {
        // If label_seq_id is 1-based (typical), use pos directly.
        // If not, we could offset — but for now we keep pos as residueNumber.
        const data = [];
        for (const pos of selected) {
          data.push({ chainId: chainIdGuess, residueNumber: pos });
        }
        return data;
      }

      function pushSelectionTo3D({ focus = false } = {}) {
        try {
          const data = buildSelectionData();
          if (data.length === 0) {
            pdbe.visual?.clearSelection?.();
            return;
          }
          pdbe.visual?.select?.({
            data,
            nonSelectedOpacity: 0.25,
            focus
          });
        } catch {
          /* no-op if API not available */
        }
      }

      // ===== Sequence click handling (single / range / toggle) =====
      seqGrid.addEventListener('click', e => {
        const t = e.target;
        if (!(t instanceof HTMLElement) || !t.classList.contains('res')) return;
        const pos = Number(t.dataset.pos);

        const isMeta = e.metaKey || e.ctrlKey;  // toggle single
        const isRange = e.shiftKey;             // select range from last

        if (!isMeta && !isRange) {
          // Single selection
          selected.clear();
          addPos(pos);
          lastClickedPos = pos;
        } else if (isRange && lastClickedPos != null) {
          addRange(lastClickedPos, pos);
          lastClickedPos = pos;
        } else if (isMeta) {
          // Toggle
          if (selected.has(pos)) removePos(pos);
          else addPos(pos);
          lastClickedPos = pos;
        }

        renderSelectionDim();
        pushSelectionTo3D({ focus: false });
      });
    }

    load();
  </script>
</body>
</html>
