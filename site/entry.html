<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Entry</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://unpkg.com/pdbe-molstar@3.7.1/build/pdbe-molstar-plugin.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/pdbe-molstar@3.7.1/build/pdbe-molstar-light.css" />
  <style>
    :root { --gap: 12px; --card-border: #ddd; --sitebar-h: 70px; }
    html, body { height: 100%; margin: 0; background: #fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#222; }

    .sitebar {
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 24px; border-bottom: 1px solid var(--card-border);
      background: #fff; height: var(--sitebar-h); box-sizing: border-box;
    }
    /* Title + logo in header */
    .site-title {
      display:flex; align-items:center; gap:10px;
      font-size:22px; font-weight:600; margin:0; line-height:1.2;
    }
    .site-title-text { white-space:nowrap; }
    .site-logo {
      height:2em;       /* match text height */
      width:auto;       /* keep aspect ratio */
      display:inline-block;
      vertical-align:middle;
    }

    .topbar {
      display: flex; align-items: center; gap: 12px; padding: 12px 16px;
      border-bottom: 1px solid var(--card-border); background: #fff;
    }
    .topbar a { text-decoration: none; }
    .title { font-size: 20px; font-weight: 600; margin: 0; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .subtitle { font-weight: 400; color:#555; font-size: 16px; }

    .main {
      height: calc(100vh - var(--sitebar-h) - 54px);
      display: flex; gap: var(--gap); padding: var(--gap); box-sizing: border-box;
    }
    .col {
      flex: 1 1 50%; min-width: 0; display: flex; flex-direction: column;
      border: 1px solid var(--card-border); border-radius: 8px; overflow: hidden; background: #fff;
    }

    #viewer-wrap { position: relative; flex: 1 1 auto; }
    #viewer { position: absolute; inset: 0; }
    #viewer .msp-viewport, #viewer canvas { width: 100% !important; height: 100% !important; max-width: 100% !important; max-height: 100% !important; }
    .msp-left-panel,.msp-right-panel,.msp-bottom-panel,.msp-layout-controls,.msp-viewport-controls,.msp-plugin-ui,.msp-controls,.msp-controls-wrapper,.msp-help-toast { display: none !important; visibility: hidden !important; pointer-events: none !important; }

    .seq-header { display: flex; align-items: center; gap: 12px; padding: 10px 12px; border-bottom: 1px solid var(--card-border); background: #fafafa; flex-wrap: wrap; }
    .btn { padding: 6px 10px; border: 1px solid var(--card-border); border-radius: 6px; cursor: pointer; background: #fff; }

    .dropdown { position: relative; }
    .dropdown-menu {
      position: absolute; top: calc(100% + 6px); left: 0; min-width: 180px; padding: 6px;
      border: 1px solid var(--card-border); border-radius: 8px; background: #fff; box-shadow: 0 8px 24px rgba(0,0,0,.08);
      display: none; z-index: 5;
    }
    .dropdown.open .dropdown-menu { display: block; }
    .menu-item { display: block; width: 100%; text-align: left; border: 0; background: none; padding: 8px 10px; border-radius: 6px; cursor: pointer; font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .menu-item:hover { background: #f2f6ff; }

    .seq-body { flex: 1 1 auto; overflow: auto; padding: 12px; }
    .error { color: #b00020; padding: 8px 12px; border-top: 1px solid var(--card-border); background: #fff7f7; }

    .seq-strip { font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; user-select: none; }
    .seq-chain { margin-bottom: 10px; }
    .seq-chain h4 { margin: 8px 0 6px; font: 600 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .seq-row { display: flex; flex-wrap: wrap; align-items: center; }
    .seq-res { display: inline-block; padding: 2px 3px; margin: 0 1px 1px 0; border-radius: 3px; cursor: pointer; }
    .seq-res:hover { background:#eef6ff; }
    .seq-res.active { background:#cfe8ff; outline: 1px solid #8bbcff; }
    .seq-res.sel { background:#bad7ff; outline: 1px solid #7fb0ff; }
    .seq-res.drag { background:#dfeeff; outline: 1px dashed #9ac3ff; }
    .muted { color:#666; font-size:12px; margin: 6px 0 0; }
  </style>
</head>
<body>
  <div class="sitebar">
    <h1 class="site-title">
      <span class="site-title-text">Computational Structure Database</span>
      <img class="site-logo" src="YOUR_LOGO_URL_HERE" alt="Project logo" />
    </h1>
  </div>

  <div class="topbar">
    <a href="index.html">← Back</a>
    <h1 class="title">
      <span id="title-id"></span>
      <span id="title-name" class="subtitle"></span>
    </h1>
  </div>

  <div class="main">
    <div class="col">
      <div id="viewer-wrap"><div id="viewer"></div></div>
      <div id="viewer-error" class="error" style="display:none;"></div>
    </div>

    <div class="col">
      <div class="seq-header">
        <div class="dropdown" id="downloadDropdown">
          <button class="btn" id="downloadBtn">Download Files ▾</button>
          <div class="dropdown-menu" id="downloadMenu">
            <button class="menu-item" id="dlCifBtn">Download CIF</button>
            <button class="menu-item" id="dlFastaBtn">Download FASTA</button>
          </div>
        </div>
        <button id="copyBtn" class="btn" type="button">Copy Sequence</button>
      </div>
      <div class="seq-body" id="seq-body"></div>
      <div id="seq-error" class="error" style="display:none;"></div>
    </div>
  </div>

  <script>
    function getParam(name){ return new URL(location.href).searchParams.get(name); }

    // ==== Configure where the names CSV lives ====
    const PROTEIN_NAMES_URL = 'https://raw.githubusercontent.com/BM-DB/uniprot-data/refs/heads/main/Protein-Metadata/protein_names.csv';

    async function loadNameMap() {
      const map = new Map();
      try {
        const res = await fetch(PROTEIN_NAMES_URL + '?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const text = await res.text();
        const lines = text.split(/\r?\n/).filter(l => l.trim().length);
        if (!lines.length) return map;

        const header = lines[0].split(',').map(s => s.trim());
        const uidIdx = header.findIndex(h => /uniprot\s*id/i.test(h));
        const nameIdx = header.findIndex(h => /protein\s*name/i.test(h));
        if (uidIdx === -1 || nameIdx === -1) return map;

        for (let i = 1; i < lines.length; i++) {
          const parts = lines[i].split(',');
          if (parts.length <= Math.max(uidIdx, nameIdx)) continue;
          const uid = (parts[uidIdx] || '').trim();
          const name = (parts[nameIdx] || '').trim();
          if (uid) map.set(uid, name || '');
        }
      } catch (e) {
        console.warn('Could not load protein_names.csv:', e);
      }
      return map;
    }

    function pdbeHighlight(viewer, asym, auth) {
      try { viewer.visual.highlight({ data: [{ struct_asym_id: asym, start_residue_number: auth, end_residue_number: auth }] }); } catch {}
    }
    function pdbeClearHighlight(viewer) { try { viewer.visual.clearHighlight(); } catch {} }
    function pdbeSelectRanges(viewer, ranges) {
      try { viewer.visual.select({ data: ranges.map(r => ({ struct_asym_id: r.asym, start_residue_number: r.start, end_residue_number: r.end }))}); } catch {}
    }
    function pdbeClearSelection(viewer) { try { viewer.visual.clearSelection?.(); } catch {} }

    function enableDragSelect(container, chainsMeta, viewer) {
      const selected = new Map();
      function normalizeRange(a,b){ return [Math.min(a,b), Math.max(a,b)]; }
      function mergeRanges(arr){ arr.sort((x,y)=>x[0]-y[0]); const out=[]; for(const r of arr){ if(!out.length||r[0]>out[out.length-1][1]+1) out.push(r); else out[out.length-1][1]=Math.max(out[out.length-1][1],r[1]); } return out; }
      function addRangeIdx(asym, startIdx, endIdx){
        const meta = chainsMeta.get(asym); if(!meta) return;
        const [a,b]=normalizeRange(startIdx,endIdx);
        const startAuth = meta.items[a].auth, endAuth = meta.items[b].auth;
        const arr = selected.get(asym)||[]; arr.push([startAuth,endAuth]); selected.set(asym, mergeRanges(arr));
      }
      function toggleSingleIdx(asym, idx){
        const meta = chainsMeta.get(asym); if(!meta) return;
        const auth = meta.items[idx].auth;
        let arr = selected.get(asym)||[]; let changed=false;
        for (let i=0;i<arr.length;i++){
          const [s,e]=arr[i];
          if(auth>=s && auth<=e){
            arr.splice(i,1);
            if(auth>s) arr.splice(i,0,[s,auth-1]);
            if(auth<e) arr.splice(i,0,[auth+1,e]);
            changed=true; break;
          }
        }
        if(!changed) arr.push([auth,auth]);
        selected.set(asym, mergeRanges(arr));
      }
      function clearSelected(){
        selected.clear();
        chainsMeta.forEach(meta => meta.items.forEach(x => x.el.classList.remove('sel')));
        pdbeClearSelection(viewer);
      }
      function paintSelected(){
        chainsMeta.forEach((meta, asym) => {
          meta.items.forEach(x => x.el.classList.remove('sel'));
          const arr = selected.get(asym)||[];
          if(!arr.length) return;
          const mark = new Set(); arr.forEach(([s,e]) => { for(let v=s; v<=e; v++) mark.add(v); });
          meta.items.forEach(x => { if(mark.has(x.auth)) x.el.classList.add('sel'); });
        });
        const pdbeRanges=[];
        selected.forEach((arr,asym)=>arr.forEach(([s,e])=>pdbeRanges.push({asym,start:s,end:e})));
        if(pdbeRanges.length) pdbeSelectRanges(viewer, pdbeRanges); else pdbeClearSelection(viewer);
      }

      chainsMeta.forEach((meta, asym) => {
        let dragging=false, anchorIdx=-1, lastIdx=-1;
        function clearDragPaint(){ meta.items.forEach(x => x.el.classList.remove('drag')); }
        function paintDrag(a,b){ clearDragPaint(); const [s,e]=normalizeRange(a,b); for(let i=s;i<=e;i++) meta.items[i].el.classList.add('drag'); }

        meta.items.forEach((x, idx) => {
          const el = x.el;
          el.addEventListener('mouseenter', ()=> pdbeHighlight(viewer, x.asym, x.auth));
          el.addEventListener('mouseleave', ()=> pdbeClearHighlight(viewer));
          el.addEventListener('mousedown', (ev) => { ev.preventDefault(); dragging=true; anchorIdx=idx; lastIdx=idx; meta.lastAnchorIdx=idx; paintDrag(anchorIdx, idx); });
          el.addEventListener('mousemove', () => { if(dragging && lastIdx!==idx){ lastIdx=idx; paintDrag(anchorIdx,lastIdx); } });
          el.addEventListener('mouseup', (ev) => {
            if(!dragging) return;
            dragging=false; clearDragPaint();
            const [sIdx,eIdx]=normalizeRange(anchorIdx,lastIdx);
            if (ev.shiftKey && typeof meta.lastAnchorIdx === 'number') {
              const [sa,se]=normalizeRange(meta.lastAnchorIdx, idx);
              addRangeIdx(asym, sa, se);
            } else if (ev.metaKey || ev.ctrlKey) {
              addRangeIdx(asym, sIdx, eIdx);
            } else {
              selected.clear(); addRangeIdx(asym, sIdx, eIdx);
            }
            paintSelected();
          });
          el.addEventListener('click', (ev) => {
            if (dragging) return;
            if (ev.metaKey || ev.ctrlKey) {
              toggleSingleIdx(asym, idx);
            } else if (ev.shiftKey && typeof meta.lastAnchorIdx === 'number') {
              const [sa,se]=normalizeRange(meta.lastAnchorIdx, idx);
              selected.clear(); addRangeIdx(asym, sa, se);
            } else {
              selected.clear(); addRangeIdx(asym, idx, idx); meta.lastAnchorIdx=idx;
            }
            paintSelected();
          });
        });

        meta.elRow.addEventListener('mouseleave', ()=>{ dragging=false; clearDragPaint(); });
      });

      container.addEventListener('mousedown', (ev) => {
        if (ev.target.closest('.seq-res')) return;
        clearSelected();
      });

      return {
        clear: clearSelected,
        getSelectedRanges: () => {
          const out=[]; selected.forEach((arr,asym)=>arr.forEach(([s,e])=>out.push({asym,start:s,end:e})));
          return out;
        }
      };
    }

    function buildStripFromFasta(seqText, viewer) {
      const seq = seqText.split(/\r?\n/).filter(l => !l.startsWith('>')).join('\n').replace(/\s+/g,'').trim();
      const container = document.createElement('div'); container.className = 'seq-strip';
      const block = document.createElement('div'); block.className = 'seq-chain';
      const header = document.createElement('h4'); header.textContent = 'Chain A Sequence';
      const row = document.createElement('div'); row.className = 'seq-row';
      block.appendChild(header); block.appendChild(row);
      const chainsMeta = new Map(); const items = [];
      for (let i = 0; i < seq.length; i++) {
        const auth = i + 1; const asym = 'A';
        const sp = document.createElement('span');
        sp.className = 'seq-res'; sp.textContent = seq[i] || 'X';
        sp.title = `${seq[i] || 'X'} ${auth}`;
        sp.dataset.asym = asym; sp.dataset.auth = String(auth);
        row.appendChild(sp); items.push({ auth, asym, el: sp });
      }
      chainsMeta.set('A', { items, elRow: row, lastAnchorIdx: null });
      container.appendChild(block);
      const note = document.createElement('div'); note.className = 'muted';
      note.textContent = 'Interactive sequence: hover, click, and drag to select residues.';
      container.appendChild(note);
      enableDragSelect(container, chainsMeta, viewer);
      return container;
    }

    function buildStripFromModel(model, viewer) {
      const { residues, chains } = model.atomicHierarchy || {};
      if (!residues || !chains) return null;
      const label_comp_id = residues.label_comp_id;
      const auth_seq_id   = residues.auth_seq_id;
      const chainIndex    = residues.chainIndex;
      const label_asym_id = chains.label_asym_id;
      if (!label_comp_id || !auth_seq_id || !chainIndex || !label_asym_id) return null;

      const to1 = (aa3) => {
        const m = {ALA:'A',ARG:'R',ASN:'N',ASP:'D',CYS:'C',GLN:'Q',GLU:'E',GLY:'G',HIS:'H',ILE:'I',LEU:'L',LYS:'K',MET:'M',PHE:'F',PRO:'P',SER:'S',THR:'T',TRP:'W',TYR:'Y',VAL:'V',SEC:'U',PYL:'O'};
        return m[aa3?.toUpperCase()] || 'X';
      };

      const perChain = new Map();
      const nResidues = residues._rowCount | 0;
      for (let rI = 0; rI < nResidues; rI++) {
        const cIdx  = chainIndex[rI];
        const asym  = label_asym_id.value(cIdx);
        const comp3 = label_comp_id.value(rI);
        const auth  = auth_seq_id.value(rI);
        if (!perChain.has(asym)) perChain.set(asym, []);
        perChain.get(asym).push({ one: to1(comp3), three: comp3, auth, asym });
      }

      const container = document.createElement('div'); container.className = 'seq-strip';
      const chainsMeta = new Map();
      perChain.forEach((list, asym) => {
        const block = document.createElement('div'); block.className = 'seq-chain';
        const header = document.createElement('h4'); header.textContent = `Chain ${asym}`;
        const row = document.createElement('div'); row.className = 'seq-row';
        block.appendChild(header); block.appendChild(row);

        const items = [];
        list.forEach(res => {
          const sp = document.createElement('span');
          sp.className = 'seq-res';
          sp.textContent = res.one;
          sp.title = `${res.three} ${res.auth}`;
          sp.dataset.asym = res.asym;
          sp.dataset.auth = String(res.auth);
          row.appendChild(sp);
          items.push({ auth: res.auth, asym: res.asym, el: sp });
        });

        chainsMeta.set(asym, { items, elRow: row, lastAnchorIdx: null });
        container.appendChild(block);
      });

      enableDragSelect(container, chainsMeta, viewer);
      return container;
    }

    async function waitForModel(viewer, timeoutMs=12000) {
      const start = performance.now();
      const plugin = viewer?.viewerInstance?.plugin;
      while (performance.now() - start < timeoutMs) {
        const hier = plugin?.managers?.structure?.hierarchy?.current;
        const sRef = hier?.structures?.[0];
        const structure = sRef?.cell?.obj?.data?.structure;
        const model = structure?.models?.[0];
        if (model?.atomicHierarchy) return model;
        await new Promise(r => setTimeout(r, 120));
      }
      return null;
    }

    async function downloadFile(url, filenameFallback) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('Network error');
        const blob = await res.blob();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filenameFallback;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      } catch (e) {
        alert('Download failed. Please try again.');
      }
    }

    async function load(){
      const uid = getParam('uid');
      const titleIdEl   = document.getElementById('title-id');
      const titleNameEl = document.getElementById('title-name');
      const viewerErr   = document.getElementById('viewer-error');
      const seqErr      = document.getElementById('seq-error');
      const seqBody     = document.getElementById('seq-body');

      const copyBtn     = document.getElementById('copyBtn');
      const dlCifBtn    = document.getElementById('dlCifBtn');
      const dlFastaBtn  = document.getElementById('dlFastaBtn');
      const dropdown    = document.getElementById('downloadDropdown');
      const downloadBtn = document.getElementById('downloadBtn');

      titleIdEl.textContent = uid || '(missing uid)';
      titleNameEl.textContent = '';

      // Load name map from uniprot-data repo
      const NAME_MAP = await loadNameMap();
      if (uid) {
        const nm = NAME_MAP.get(uid);
        if (nm) titleNameEl.textContent = `— ${nm}`;
      }

      function closeDropdown(){ dropdown.classList.remove('open'); }
      function toggleDropdown(){ dropdown.classList.toggle('open'); }
      downloadBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleDropdown(); });
      document.addEventListener('click', closeDropdown);

      let catalog;
      try {
        catalog = await fetch('../data/entries.json?v=' + Date.now()).then(r=>r.json());
      } catch {
        viewerErr.style.display = seqErr.style.display = 'block';
        viewerErr.textContent = seqErr.textContent = 'Could not load entries.json.';
        return;
      }

      const entry = (catalog.entries || []).find(e => e.uniprot_id === uid);
      if(!entry){
        viewerErr.style.display = seqErr.style.display = 'block';
        viewerErr.textContent = seqErr.textContent = 'Entry not found in catalog.';
        return;
      }

      const cifUrl   = entry.files.structure_cif;
      const fastaUrl = entry.files.sequence_fasta;

      let fastaText = '';
      try { fastaText = await fetch(fastaUrl, { cache: 'no-store' }).then(r=>r.text()); }
      catch { seqErr.style.display = 'block'; seqErr.textContent = 'FASTA not available.'; }

      copyBtn.onclick = async () => {
        const seqOnly = (fastaText || '')
          .split(/\r?\n/).filter(l => !l.startsWith('>')).join('\n')
          .replace(/\s+/g, '').trim();
        if (!seqOnly) return;
        try {
          await navigator.clipboard.writeText(seqOnly);
          const prev = copyBtn.textContent; copyBtn.textContent = 'Copied!';
          setTimeout(()=> (copyBtn.textContent = prev), 1200);
        } catch {}
      };

      const cifName = (() => {
        const urlLower = cifUrl.toLowerCase();
        const ext = urlLower.endsWith('.cif') && !urlLower.endsWith('.mmcif') ? '.cif' : '.mmcif';
        return (uid || 'structure') + ext;
      })();
      const fastaName = (uid || 'sequence') + '.fasta';

      dlCifBtn.onclick   = async () => { closeDropdown(); await downloadFile(cifUrl,   cifName);   };
      dlFastaBtn.onclick = async () => { closeDropdown(); await downloadFile(fastaUrl, fastaName); };

      const fmt = (cifUrl.toLowerCase().endsWith('.cif') && !cifUrl.toLowerCase().endsWith('.mmcif')) ? 'cif' : 'mmcif';
      let pdbe;
      try { pdbe = new PDBeMolstarPlugin(); }
      catch { viewerErr.style.display = 'block'; viewerErr.textContent = 'Failed to create PDBe Mol* plugin.'; return; }

      try {
        pdbe.render('viewer', { customData: { url: cifUrl, format: fmt }, hideControls: true, expanded: false, bgColor: { r:255, g:255, b:255 } });
      } catch {
        viewerErr.style.display = 'block';
        viewerErr.textContent = 'Mol* render error.';
        return;
      }

      const root = document.getElementById('viewer');
      const hideChrome = () => {
        [
          '.msp-left-panel','.msp-right-panel','.msp-bottom-panel',
          '.msp-layout-controls','.msp-viewport-controls',
          '.msp-plugin-ui','.msp-controls','.msp-controls-wrapper','.msp-help-toast'
        ].forEach(sel => { document.querySelectorAll(sel).forEach(el => { el.style.display='none'; el.style.visibility='hidden'; el.style.pointerEvents='none'; }); });
      };
      hideChrome(); setTimeout(hideChrome, 100); setTimeout(hideChrome, 500);
      new MutationObserver(hideChrome).observe(root, { childList:true, subtree:true });

      function styleScene() {
        try {
          const plugin = pdbe?.viewerInstance?.plugin;
          const c3d = plugin?.canvas3d;
          if (c3d?.setProps) {
            c3d.setProps({
              renderer: { ambientIntensity: 0.6 },
              postprocessing: { outline: { enable: true, scale: 1.0, threshold: 0.8 } }
            });
          }
        } catch {}
      }
      setTimeout(styleScene, 400);
      setTimeout(styleScene, 1200);

      if (fastaText) {
        seqBody.innerHTML = '';
        seqBody.appendChild(buildStripFromFasta(fastaText, pdbe));
      } else {
        const p = document.createElement('div');
        p.className = 'muted';
        p.textContent = 'Waiting for structure…';
        seqBody.innerHTML = ''; seqBody.appendChild(p);
      }

      const model = await waitForModel(pdbe, 12000);
      if (model) {
        const strip = buildStripFromModel(model, pdbe);
        if (strip) { seqBody.innerHTML = ''; seqBody.appendChild(strip); }
      }
    }

    load();
  </script>
</body>
</html>
